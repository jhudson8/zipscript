<?xml version='1.0'?>
<!-- <!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"> -->
<set id="zipscript">
	<index/>
	<book id="userGuide">
		<bookinfo>
			<title>ZipScript User Guide</title>
		</bookinfo>
		<chapter id="userGuideGettingStarted">
			<title>Getting Started</title>
			<para>
				This guide is an introduction to writing templates and expression using the ZipScript language.
			</para>
			<section id="userGuideBasics">
				<para>
					If you need an HTML page that is similar to this:
<programlisting>
<html>
	<head><title>My Page Title</title></head>
	<body>
		The error message is: "something bad happened"
	</body>
</html>
</programlisting>
					There are aspects of this output that could change depending on the situation like the title and message text.  Using the ZipScript
					engine, you can handle situations like this by creating a template and reference context variables.  The template to reference the
					output above would look something like this:
<programlisting>
<html>
	<head><title>${title}</title></head>
	<body>
		The ${message.type} message is: "${message.text}"
	</body>
</html>
</programlisting>
				</para>
				<para>
					So what does <emphasis>${title}</emphasis>, and <emphasis>${message.type}</emphasis> and <emphasis>${message.text}</emphasis> mean?
					When the ZipScript merge occurs, a context is used to contain the data model which will be accessed from the template.  The previous
					template example assumes that the context has 2 entries:
					<itemizedlist>
						<listitem><emphasis>title</emphasis>: text equal to "My Page Title"</listitem>
						<listitem><emphasis>message</emphasis>: A message object containing the following methods / map entries...
							<itemizedlist>
								<listitem><emphasis>method: getType() or map attribute: "type"</emphasis>: text equal to "error"</listitem>
								<listitem><emphasis>method: getText() or map attribute: "text"</emphasis>: text equal to "something bad happened"</listitem>
							</itemizedlist>
						</listitem>
					</itemizedlist>
				</para>
				<para>
					The templates could be located anywhere including the filesystem or classpath or even remote URL's.  Several resource loaders are
					included with ZipScript but new ones can be created if the default loaders are not adequate. 
				</para>
			</section>
			<section id="userGuideDataModel">
				<title>Data Model</title>
				<para>
					Assume the following data structure:
<programlisting>
&gt;
 +- myCar
 |  |
 |  +- model = "Honda"
 |  |
 |  +- numTires = 4
 |  |
 |  +- engine
 |  |  |
 |  |  +- numCylinders = 4
 |  |  |
 |  |  +- horsePower = 135
 |  |
 |  +- milesPerGalon = 35
 |
 +- driver
    |
    +- firstName = "Joe"
    |
    +- lastName = "Hudson"
    |
    +- children
       |
       +- (1st)
       |  |
       |  +- firstName = "Clark"
       |  |
       |  +- lastName = "Kent"
       |
       +- (2nd)
          |
          +- firstName = "Bill"
          |
          +- lastName = "Bixby"
</programlisting>
				</para>
				<para>
					<itemizedlist>
						<listitem>Directory variables (ex: myCar, driver) are called <emphasis>hashes</emphasis></listitem>
						<listitem>Single-vlue variables (ex: model under myCar) are called <emphasis>scalars</emphasis></listitem>
						<listitem>List variables (ex: children under driver) are called <emphasis>sequences</emphasis></listitem>
					</itemizedlist>
				</para>
				<para>
					Variables can be referenced using the syntax <code>${...}</code>
					To reference any variable in the template the path from the root must be specified.  Each path segment
					must be separated by a dot.  Sequences allow for additional functionality.  Because they contain a list of
					items, indexes can be references to retrieved individual sequence elements.  The index is referenced as [0-based number].
				</para>
				<para>
					The following examples reference the previously defined data model.  Note the quotation marks are used to reference output and would not actually be printed.
<programlisting>
${myCar.model} will print "Honda"
${myCar.engine.numCylinders} will print "4"
${driver.firstName} will print "Joe"
${driver.children[0].firstName} will print "Bill"
</programlisting>
				</para>
				<para>
					Scalars can be sub-divided into different groups with different special methods and formatting functions
					<itemizedlist>
						<listitem><emphasis>text</emphasis>: an arbitrary sequence of characters</listitem>
						<listitem><emphasis>number</emphasis>: any type of number</listitem>
						<listitem><emphasis>date</emphasis>: any type of date</listitem>
						<listitem><emphasis>boolean</emphasis>: a true/false value</listitem>
					</itemizedlist>
				</para>
			</section>
			<section id="gettingStartedTemplateParts">
				<title>Template Overview</title>
				<para>
					There are 5 syntax statements that can be used within a template which will be described in detail later in this guide:
					<itemizedlist>
						<listitem><emphasis>variable</emphasis>: Any variable reference</listitem>
						<listitem><emphasis>comment</emphasis>: A ZipScript comment which would not be printed out in merged results</listitem>
						<listitem><emphasis>directives</emphasis>: ZipScript instructions which allow conditional evaluation, looping, etc...</listitem>
						<listitem><emphasis>macros</emphasis>: A nested or flat pre-defined bit of ZipScript language</listitem>
						<listitem><emphasis>template defined macro parameters</emphasis>: Similar in structure to a macro definition but represents macro input</listitem>
					</itemizedlist>
				</para>
			</section>
		</chapter>
	
		<chapter id="variables">
			<title>Variables</title>
			<section id="variable_overview">
				<title>Overview</title>
				<para>
					Variables can be used to reference data from the context.  The standard
					variable format is ${...}.  This will assume that a <link linkend="context">context</link> entry with
					the key of "varName" exists.  To allow for a nonexisting <link linkend="context">context</link> entry the
					syntax that should be used is $!{varName}.
				</para>
				<para>
					Assume the <link linkend="context">context</link> value <emphasis>foo</emphasis> is equal to "abc"
					<itemizedlist>
						<listitem>${foo} will print <code>abc</code></listitem>
						<listitem>${foo.length} will print <code>3</code></listitem>
						<listitem>${foo.substring(1)} will print <code>oo</code></listitem>
						<listitem>${foo.class.name} will print <code>java.lang.String</code></listitem>
		      		</itemizedlist>
		      		<itemizedlist>
		      			<listitem>${bar} will throw an ExecutionException (assuming no "bar" entry is in the context)</listitem>
		      			<listitem>$!{bar} will not print anything</listitem>
		      		</itemizedlist>
				</para>
				<para>
					Variables can reference boolean or math operators.
					Assume the <link linkend="context">context</link> value <emphasis>foo</emphasis> is equal to the number 3
					<itemizedlist>
						<listitem>${foo+3} will print <code>6</code></listitem>
						<listitem>${foo*3} will print <code>9</code></listitem>
						<listitem>${foo/3} will print <code>1.0</code></listitem>
						<listitem>${foo-3} will print <code>0</code></listitem>
						<listitem>${foo%3} will print <code>0</code></listitem>
						<listitem>${foo!=3} will print <code>false</code> (or evaluate to false)</listitem>
						<listitem>${foo==3} will print <code>true</code> (or evaluate to true)</listitem>
						<listitem>${foo&lt;4} will print <code>true</code> (or evaluate to true)</listitem>
						<listitem>${foo&gt;=4} will print <code>false</code> (or evaluate to false)</listitem>
					</itemizedlist>
				</para>
				<note>
					For more examples, check out:
					<itemizedlist>
						<listitem>
							<ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/test/hudson/zipscript/VariableTestCase.java">VariableTestCase.java</ulink>
							<itemizedlist>
								<listitem>Script reference: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/templates/variable_simple_test.zs">variable_simple_test.zs</ulink></listitem>
								<listitem>Output reference: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/templates/variable_simple_result.txt">variable_simple_result.txt</ulink></listitem>
							</itemizedlist>
						</listitem>
					</itemizedlist>
				</note>
			</section>
			<section id="variable_escape">
				<title>Variable Escaping</title>
				<para>
					Variable references can be escaped by using the '\' prefix.  Escaping is only required if the character is next
					to a variable or directive.  For example, assume the <link linkend="context">context</link> value <emphasis>foo</emphasis> is equal to "ABC"
					<itemizedlist>
						<listitem>foo\test${foo} will print <code>foo\testABC</code></listitem>
						<listitem>foo\\test${foo} will print <code>foo\\testABC</code></listitem>
						<listitem>test\${foo} will print <code>test${foo}</code></listitem>
						<listitem>test\\${foo} will print <code>test\ABC</code></listitem>
						<listitem>test\\\${foo} will print <code>test\${foo}</code></listitem> 
					</itemizedlist>
				</para>
			</section>
			<section id="variable_default">
				<title>Default Values</title>
				<para>
					All variables can use the '!' token to provide a default value which will
					be used if the requested <link linkend="context">context</link> attribute is missing.
				</para>
				<para>
					Assume the <link linkend="context">context</link> value <emphasis>foo</emphasis> is missing and the
					context value <emphasis>bar</emphasis> is equal to "Hello"
					<itemizedlist>
						<listitem>${foo!"Static Default Text"} will print <code>Static Default Text</code></listitem>
						<listitem>${foo!bar} will print <code>Hello</code></listitem>
						<listitem>${foo!somethingElseMissing!bar} will print <code>Hello</code></listitem>
						<listitem>${foo!3} will print <code>3</code></listitem>
						<listitem>${foo!true} will print <code>true</code></listitem>
						<listitem>${foo!false} will print <code>false</code></listitem>
					</itemizedlist>
				</para>
				<note>
					For more examples, check out:
					<itemizedlist>
						<listitem>
							<ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/test/hudson/zipscript/VariableDefaultsTestCase.java">VariableTestCase.java</ulink>
						</listitem>
					</itemizedlist>
				</note>
			</section>
			<section id="variable_format">
				<title>Formatting</title>
				<para>
					Some variables can use the '|' token to provide formatting options.
				</para>
				<section id="variable_format_dates">
					<title>Dates</title>
					<para>
						short/medium/long keywords are used for date formatting
						<itemizedlist>
							<indexterm><primary>dates</primary><secondary>formatting (short)</secondary></indexterm>
							<listitem>${myDate|short} will print <code>01/01/2008</code></listitem>
							<indexterm><primary>dates</primary><secondary>formatting (medium)</secondary></indexterm>
							<listitem>${myDate|medium} will print <code>Jan 01, 2008</code></listitem>
							<indexterm><primary>dates</primary><secondary>formatting (long)</secondary></indexterm>
							<listitem>${myDate|long} will print <code>January 01, 2008</code></listitem>
						</itemizedlist>
						t_short/t_medium/t_long are used for time formatting
						<itemizedlist>
							<indexterm><primary>dates</primary><secondary>formatting (time short)</secondary></indexterm>
							<listitem>${myDate|t_short} will print <code>10:37 AM</code></listitem>
							<indexterm><primary>dates</primary><secondary>formatting (time medium)</secondary></indexterm>
							<listitem>${myDate|t_medium} will print <code>10:37:18 AM</code></listitem>
							<indexterm><primary>dates</primary><secondary>formatting (time long)</secondary></indexterm>
							<listitem>${myDate|t_long} will print <code>10:37:18 AM EDT</code></listitem>
						</itemizedlist>
						date &amp; time formatting can be used by appending formatting styles
						<itemizedlist>
							<indexterm><primary>dates</primary><secondary>formatting (date and time)</secondary></indexterm>
							<listitem>${myDate|short_long} will print <code>01/01/2008 10:37:18 AM EDT</code></listitem>
						</itemizedlist>
						Custom formatting can also be used
						<itemizedlist>
							<indexterm><primary>dates</primary><secondary>formatting (custom)</secondary></indexterm>
							<listitem>${myDate|"yy-MM-dd"} will print <code>2008-01-01</code></listitem>
						</itemizedlist>
					</para>
				<note>
					For more examples, check out:
					<itemizedlist>
						<listitem>
							<ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/test/hudson/zipscript/VariableFormattingTestCase.java">VariableFormattingTestCase.java</ulink>
						</listitem>
					</itemizedlist>
				</note>
				</section>
				<section id="variable_format_numbers">
					<title>Numbers</title>
					<para>
						number/currency/percent keywords are used for number formatting (using Locale)
						<itemizedlist>
							<listitem>${myNumber} will print <code>1234567.2</code></listitem>
							<indexterm><primary>numbers</primary><secondary>formatting (general)</secondary></indexterm>
							<listitem>${myNumber|number} will print <code>1,234,567.2</code></listitem>
							<indexterm><primary>numbers</primary><secondary>formatting (currency)</secondary></indexterm>
							<listitem>${myNumber|currency} will print <code>$1,234,567.20</code></listitem>
							<indexterm><primary>numbers</primary><secondary>formatting (percent)</secondary></indexterm>
							<listitem>${myNumber|percent} will print <code>123456720%</code></listitem>
						</itemizedlist>
						Custom formatting can also be used
						<itemizedlist>
							<indexterm><primary>numbers</primary><secondary>formatting (custom)</secondary></indexterm>
							<listitem>${myNumber|"#.000"} will print <code>1234567.200</code></listitem>
						</itemizedlist>
					</para>
				</section>
			</section>
			<section id="variable_specialMethods">
				<title>Special Methods</title>
				<para>
					All variables can use the '?' token to provide special functionality.
				</para>
				<section id="variable_specialMethods_strings">
					<title>Strings</title>
					<para>
						Assume the <link linkend="context">context</link> value "myString" is "hello world!"
						<itemizedlist>
							<indexterm><primary>strings</primary><secondary>?upperFirst</secondary></indexterm>
							<listitem>${myString?upperFirst} will print <code>Hello world!</code></listitem>
							<indexterm><primary>strings</primary><secondary>?lowerFirst</secondary></indexterm>
							<listitem>${myString?lowerFirst} will print <code>hello world!</code></listitem>
							<indexterm><primary>strings</primary><secondary>?lowerCase</secondary></indexterm>
							<listitem>${myString?lowerCase} will print <code>hello world!</code></listitem>
							<indexterm><primary>strings</primary><secondary>?upperCase</secondary></indexterm>
							<listitem>${myString?upperCase} will print <code>HELLO WORLD!</code></listitem>
							<indexterm><primary>strings</primary><secondary>?humpbackCase</secondary></indexterm>
							<listitem>${myString?humpbackCase} will print <code>helloWorld</code></listitem>
							<indexterm><primary>strings</primary><secondary>?leftPad</secondary></indexterm>
							<listitem>${myString?leftPad(2)} will print <code>  hello world!</code> (with 2 spaces on the left)</listitem>
							<indexterm><primary>strings</primary><secondary>?rightPad</secondary></indexterm>
							<listitem>${myString?rightPad(2)} will print <code>hello world!  </code> (with 2 spaces on the right)</listitem>
							<indexterm><primary>strings</primary><secondary>?contains</secondary></indexterm>
							<listitem>${myString?contains("ello")} will print <code>true</code> (or evaluate to true in an expression)</listitem>
						</itemizedlist>
						There are many convienance methods for dealing with text escaping
						<itemizedlist>
							<indexterm><primary>strings</primary><secondary>?html</secondary></indexterm>
							<listitem>${myString?html} will escape HTML special characters</listitem>
							<indexterm><primary>strings</primary><secondary>?js</secondary></indexterm>
							<listitem>${myString?js} will escape javascript special characters</listitem>
							<indexterm><primary>strings</primary><secondary>?url</secondary></indexterm>
							<listitem>${myString?url} will escape URL special characters</listitem>
							<indexterm><primary>strings</primary><secondary>?xml</secondary></indexterm>
							<listitem>${myString?xml} will escape XML special characters</listitem>
						</itemizedlist>
						Assume the <link linkend="context">context</link> value "someClassName" is "java.lang.String"
						<itemizedlist>
							<indexterm><primary>strings</primary><secondary>?split</secondary></indexterm>
							<listitem>${myString?split(".")} will return the equivalent of <code>${{"java", "lang", "String"}}</code></listitem>
						</itemizedlist>
					</para>
					<note>
						For more examples, check out:
						<itemizedlist>
							<listitem>
								<ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/test/hudson/zipscript/SpecialMethodsTestCase.java">SpecialMethodsTestCase.java</ulink>
							</listitem>
						</itemizedlist>
					</note>
				</section>
				<section id="variable_specialMethods_numbers">
					<title>Numbers</title>
					<para>
						Assume the <link linkend="context">context</link> value "myNumber" is 3.4
						<itemizedlist>
							<indexterm><primary>numbers</primary><secondary>?round</secondary></indexterm>
							<listitem>${myNumber?round} will print <code>3</code></listitem>
							<indexterm><primary>numbers</primary><secondary>?ceiling</secondary></indexterm>
							<listitem>${myString?ceiling} will print <code>4</code></listitem>
							<indexterm><primary>numbers</primary><secondary>?floor</secondary></indexterm>
							<listitem>${myString?floor} will print <code>3</code></listitem>
						</itemizedlist>
					</para>
				</section>
				<section id="variable_specialMethods_dates">
					<title>Dates</title>
					<para>
						Assume the <link linkend="context">context</link> value "myDate" is the date "01/01/2008 10:37:18 AM EDT"
						<itemizedlist>
							<indexterm><primary>dates</primary><secondary>?jsDate</secondary></indexterm>
							<listitem>${myDate?jsDate} will print <code>new Date(01, 01, 2008)</code></listitem>
							<indexterm><primary>dates</primary><secondary>?jsDateTime</secondary></indexterm>
							<listitem>${myDate?jsDateTime} will print <code>new Date(1199163600000)</code></listitem>
						</itemizedlist>
					</para>
				</section>
				<section id="variable_specialMethods_sequences">
					<title>Dates</title>
					<para>
						Assume the <link linkend="context">context</link> value "mySeq" is {"abc", "def", "ghi"}
						<itemizedlist>
							<indexterm><primary>sequences</primary><secondary>?contains</secondary></indexterm>
							<listitem>${mySeq?contains("abc")} will print <code>true</code> (or evaluate to true)</listitem>
							<indexterm><primary>sequences</primary><secondary>?first</secondary></indexterm>
							<listitem>${mySeq?first} will print <code>abc</code></listitem>
							<indexterm><primary>sequences</primary><secondary>?last</secondary></indexterm>
							<listitem>${mySeq?last} will print <code>ghi</code></listitem>
						</itemizedlist>
					</para>
				</section>
				<section id="variable_specialMethods_is">
					<title>Object Methods</title>
					<para>
						<itemizedlist>
							<indexterm><primary>objects</primary><secondary>?isDate</secondary></indexterm>
							<listitem>${obj?isDate} will be <code>true</code> if the value is a Date</listitem>
							<indexterm><primary>objects</primary><secondary>?isBoolean</secondary></indexterm>
							<listitem>${obj?isBoolean} will be <code>true</code> if the value is a boolean</listitem>
							<indexterm><primary>objects</primary><secondary>?isString</secondary></indexterm>
							<listitem>${obj?isString} will be <code>true</code> if the value is a String</listitem>
							<indexterm><primary>objects</primary><secondary>?isNumber</secondary></indexterm>
							<listitem>${obj?isNumber} will be <code>true</code> if the value is a Number</listitem>
						</itemizedlist>
					</para>
				</section>
				<section>
					<title>Template Defined Macro Parameters</title>
					<para>
						Assume the following macro reference:
						[@foo]
							${someNumber}
						[/@foo]
						<indexterm><primary>macros</primary><secondary>?objectValue</secondary></indexterm>
						<listitem>${body?objectValue} (in the foo macro definition) will be the number that someNumber represents</listitem>
					</para>
				</section>
			</section>
		</chapter>
		<chapter id="directives">
			<title>Directives</title>
			<section id="directives_overview">
				<title>Overview</title>
				<para>
					Directives are special character sequences that start with <code>[#</code> and end with <code>]</code>.  Directives
					can either be flat or nested.  Directives are used to perform some action.  The action can range from calling a macro
					to modifying the context to conditional statements and looping, etc.
					<variablelist>
						<varlistentry id="flat_directive_def"><term>flat</term><listitem>
<programlisting>
[#directive .../]
</programlisting>
						</listitem></varlistentry>
						<varlistentry id="nested_directive_def"><term>nested</term><listitem>
<programlisting>
[#directive ...]
	...
[/#directive]
</programlisting>
						</listitem></varlistentry>
					</variablelist>
					<note>
						<itemizedlist>
							<listitem>Variable references inside directive statements do not need to be wrapped with <code>${}</code> (although they can be)</listitem>
							<listitem>The indentation is not required.  It is only added for readability</listitem>
						</itemizedlist>
					</note>
				</para>
			</section>
			<section id="directives_if">
				<title>If  / Elseif / Else</title>
				<para>
					<indexterm><primary>directives</primary><secondary>if</secondary></indexterm>
					The if directive is a <link linkend="nested_directive_def">nested directive</link> with additional optional elements.
					Aside from the [#if] [/#if], [#elseif] and [#else] can be used.
					<variablelist>
						<varlistentry><term>[#if ...]</term><listitem>Used nested block if condition is true</listitem></varlistentry>
						<varlistentry><term>[#elseif ...]</term><listitem>(optional) Used nested block if condition is true and previous [#elseif] conditions are false and if condition is false</listitem></varlistentry>
						<varlistentry><term>[#else ...]</term><listitem>(optional) Use nested block if the if condition was false and all elseif conditions are false</listitem></varlistentry>
					</variablelist>
				</para>
				<para>
<programlisting>
[#if foo==${bar}]
	This section will print if the foo <link linkend="context">context</link> variable is equal to the bar <link linkend="context">context</link> variable.  Notice that variables
	inside directive expressions do not need to be referenced with ${} (but they can be).
[#elseif foo=="Joe's"]
	This section will print if the foo <link linkend="context">context</link> variable is equal to the string <code>Joe's</code>
[#elseif foo!='Joe\'s']
	This section will print if the foo <link linkend="context">context</link> variable is equal to the string <code>Joe's</code>.  Notice that strings
	can be referenced with the ' character or the " character.  This is useful if the string contains either
	of these characters.
[#elseif foo in {1, 2d, 3f}]
	This is a handy way of checking to see if a value is in a list.  This section will print if the foo <link linkend="context">context</link> variable
	is equal to 1 (Integer) or 2 (Double) or 3 (Float).
 [#elseif foo not in {"one", "two", "three"}]
	This is a handy way of checking to see if a value is not in a list.  This section will print if the foo <link linkend="context">context</link> variable
	is equal to the string <code>one</code> or the string <code>two</code> or the string <code>three</code>.
[#elseif foo &gt; 3]
	This section will print if the foo <link linkend="context">context</link> variable is greater than 3.
[#elseif foo%2==0]
	This section will print if foo is a number can be divided by 2 with a 0 remainder.
[#else]
	This section will print if none of the previous sections evaluate to true.
[/#if]
</programlisting>
				</para>
				<note>
					For more examples, check out:
					<itemizedlist>
						<listitem>Unit Test: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/test/hudson/zipscript/DirectiveTestCase.java#73">DirectiveTestCase</ulink></listitem>
						<listitem>Script reference: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/templates/if_test.zs">if_test.zs</ulink></listitem>
						<listitem>Output reference: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/templates/if_result.txt">if_result.txt</ulink></listitem>
					</itemizedlist>
				</note>
			</section>
			<section id="directives_foreach">
				<title>Foreach</title>
				<para>
					<indexterm><primary>directives</primary><secondary>foreach</secondary></indexterm>
					Syntax: <emphasis>[#foreach refItem in someList] ... [/#foreach]</emphasis>
					<variablelist>
						<varlistentry><term>refItem</term><listitem>This is the <link linkend="context">context</link> key for the current list entry</listitem></varlistentry>
						<varlistentry><term>someList</term><listitem>This can either be a variable name representing a sequence or an expression which will create a sequence</listitem></varlistentry>
					</variablelist>
				</para>
				<para>
					The foreach directive can be used to loop through a sequence.  The sequence could be a Collection, Iterator, Enumeration or Object
					array.  When inside of a foreach directive some special variables can be used:
					<variablelist>
						<varlistentry><term>i</term><listitem>The current loop index</listitem></varlistentry>
						<varlistentry><term>hasNext</term><listitem>Boolean representing if there are any remaining entries in the list to be processed</listitem></varlistentry>
						<varlistentry><term>super</term><listitem>If a loop is inside of another loop, super can be used to access loop elements in the parent scope</listitem></varlistentry>
					</variablelist>
				</para>
				<para>
<programlisting>
[#set someList = {"D", "E", "F"}/]
[#foreach item in {"a", "b", "c"}]
[#foreach item in someList]
	${super.item}.${item} (${super.i}.${i}) - ${hasNext} - ${super.hasNext}
[/#foreach]
[/#foreach]
</programlisting>
Will print
<programlisting>
a.D (0.0) - true - true
a.E (0.1) - true - true
a.F (0.2) - false - true
b.D (1.0) - true - true
b.E (1.1) - true - true
b.F (1.2) - false - true
c.D (2.0) - true - false
c.E (2.1) - true - false
c.F (2.2) - false - false
</programlisting>
				</para>
				<note>
					For more examples, check out:
					<itemizedlist>
						<listitem>Unit Test: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/test/hudson/zipscript/DirectiveTestCase.java#43">DirectiveTestCase</ulink></listitem>
						<listitem>Script reference: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/templates/foreach_test.zs">foreach_test.zs</ulink></listitem>
						<listitem>Output reference: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/templates/foreach_result.txt">foreach_result.txt</ulink></listitem>
						<listitem>Output reference: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/templates/foreach_result.txt">foreach_result_iter.txt</ulink></listitem>
					</itemizedlist>
				</note>
			</section>
			<section id="directives_while">
				<title>While</title>
				<para>
					<indexterm><primary>directives</primary><secondary>while</secondary></indexterm>
					Syntax: <emphasis>[#while expression] ... [/#while]</emphasis>
					<variablelist>
						<varlistentry><term>expression</term><listitem>Any expression which can result in a boolean value</listitem></varlistentry>
					</variablelist>
				</para>
				<para>
					The while directive can be used to loop until a condition is met.  When inside of a foreach directive some special variables can be used:
					<variablelist>
						<varlistentry><term>i</term><listitem>The current loop index</listitem></varlistentry>
						<varlistentry><term>super</term><listitem>If inside of another looping struction, super can be used to access loop elements in the parent scope</listitem></varlistentry>
					</variablelist>
					<note>hasNext is not available for a while directive</note>
				</para>
				<para>
<programlisting>
[#foreach item in {"a", "b", "c"}]
[#while i&lt;2]
	${super.item}.${i+1} (${super.i}.${i}) - ${super.hasNext}
[/#while]
[/#foreach]
</programlisting>
Will print
<programlisting>
a.1 (0.0) - true
a.2 (0.1) - true
b.1 (1.0) - true
b.2 (1.1) - true
c.1 (2.0) - false
c.2 (2.1) - false
</programlisting>
				</para>
				<note>
					For more examples, check out:
					<itemizedlist>
						<listitem>Unit Test: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/test/hudson/zipscript/DirectiveTestCase.java#67">DirectiveTestCase</ulink></listitem>
						<listitem>Script reference: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/templates/while_test.zs">while_test.zs</ulink></listitem>
						<listitem>Output reference: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/templates/while_result.txt">while_result.txt</ulink></listitem>
					</itemizedlist>
				</note>
			</section>
			<section id="directives_set">
				<title>Set</title>
				<para>
					<indexterm><primary>directives</primary><secondary>set</secondary></indexterm>
					Syntax: <emphasis>[#set newVar = something/]</emphasis>
					<variablelist>
						<varlistentry><term>newVar</term><listitem>The <link linkend="context">context</link> key that will be used to access the variable</listitem></varlistentry>
						<varlistentry><term>something</term><listitem>An expression or variable reference that will be set in the context</listitem></varlistentry>
					</variablelist>
					The set directive is used to set a value in the <link linkend="context">context</link> so it can be accessed later.
				</para>
				<para>
					Examples:
<programlisting>
[#set myVar = "abc"/] - will set myVar to the string "abc"
[#set myVar = 'abc'/] - will set myVar to the string "abc"
[#set myVar = abc/] - will set myVar to the <link linkend="context">context</link> variable with the key of "abc"
[#set myVar = 4!=4/] - will set myVar to the <link linkend="context">context</link> variable with false
[#set myVar = 4==4/] - will set myVar to the <link linkend="context">context</link> variable with true
[#set myVar = {1,2,3}/] - will set myVar to the <link linkend="context">context</link> variable with a list of element containing 1, 2, and 3
</programlisting>
				</para>
				<note>
					For more examples, check out:
					<itemizedlist>
						<listitem>Unit Test: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/test/hudson/zipscript/DirectiveTestCase.java#99">DirectiveTestCase</ulink></listitem>
						<listitem>Script reference: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/templates/foreach_test.zs">set_test.zs</ulink></listitem>
						<listitem>Output reference: <ulink url="http://code.google.com/p/zipscript/source/browse/trunk/core/src/main/test/templates/foreach_result.txt">set_result.txt</ulink></listitem>
					</itemizedlist>
				</note>
			</section>
			<section id="directives_call">
				<title>Call</title>
				<para>TODO: Document call directive</para>
			</section>
		</chapter>
		<chapter id="macros">
			<title>Macros</title>
			<section id="macros_overview">
				<title>What is a Macro?</title>
				<para>
					Macros are pre-defined ZipScript code that can be referenced using a directive-like syntax.  They can be used in a few different ways
					<itemizedlist>
						<listitem>Flat macros: Simple code snippets that can accept parameter input</listitem>
						<listitem>Nested macros: Code snippets definitions that can reference the nested content inside the macro reference using ${body}</listitem>
						<listitem>Object-oriented macros: Macros defined as components which can inspect the internal data structure of the macro reference</listitem>
					</itemizedlist>
				</para>
				<para>
					All macros have the ability to accept parameters.  All required parameters must be defined before (leftmost) all optional parameters.
					<itemizedlist>
						<listitem>Required parameters must be prefixed with *</listitem>
						<listitem>Optional parameters <emphasis>can</emphasis> be assigned a default value using =</listitem>
						<listitem>Multiple parameters should be separated by a space</listitem>
					</itemizedlist>
					Every macro would have a definition and one or more references.  The definition would have the following syntax:
<programlisting>
[#macro macroName *requiredParam1 optionalDefaultedParam1="abc" optionalNonDefaultedParam]
    The macro parameters can be referenced like ${requiredParam1} ${optionalDefaultedParam1} ${optionalNonDefaultedParam!"Some default because param might be null"}
    The macro body contents can be referenced with ${body} *this is not available for flat macro references*
[/#macro]
</programlisting>
				</para>
				<para>
					The syntax of a flat macro reference is:
<programlisting>
[@someMacro requiredParam1="foo"/]  &lt;-- named attribute access
</programlisting>
					The syntax of a nested macro reference is:
<programlisting>
[@someMacro "foo"]  &lt;-- ordinal attribute access
   This is the macro body
[/@someMacro]
</programlisting>
				</para>
			</section>
			<section id="macros_definition">
				<title>Macro Definitions</title>
				<para>
					The syntax for a macro definition is <code>[#macro macroName ...]</code> macro body content [/#macro].
				</para>
				<para>
					<itemizedlist>
						<listitem>All parameters to be used within the macro should be referenced after the macro name in the definition.</listitem>
						<listitem>Parameters must either be required or supply a default value (which can be null).</listitem>
						<listitem>Default parameter values use the '=' characer to assign the default value</listitem>
						<listitem>Any parameters referenced in the macro definition will be available in the context.  See example below:</listitem>
						<listitem>All required parameters must be listed first (leftmost) with optional parameters listed last (rightmost)</listitem>
						<listitem>Parameters must be separated by spaces</listitem>
					</itemizedlist>
					See example:
<programlisting>
[#macro myMacro requiredParam1 requiredParam2 optionalStringParam="abc" optionalNumberParam=3 optionalListParam={1,2,3} optionalContextParam=foo]
	The first parameter is ${requiredParam1}
	The second parameter is ${requiredParam2}
	The third optional parameter (with default) is ${optionalStringParam|"def"}
	The fourth optional parameter (with silence) is $!{optionalNumberParam}
	[#if optionalListParam!=null]
		[#foreach entry in optionalListParam]
			the list value is ${entry}
		[/#foreach]
	[/#if]
	The last param is ${optionalContextParam} &lt;-- an ExecutionException will be thrown if this value is null

	The nested content of the macro reference is ${body}
[/#macro]
See the next section to understand how to reference this macro
</programlisting>
				</para>
			</section>
			<section id="macros_referencing">
				<title>Macro Referencing</title>
				<para>
					Unlike other directives, macros are referenced using the '@' character instead of the '#' character.
					Macros references can pass parameters ordinally or by name (more like an XML format).
<emphasis>Reference with named parameters</emphasis>
<programlisting>
[@myMacro requiredParam1=someContextVar requiredParam2="foo" optionalStringParam="bar" optionalContextParam=someVar]
	The content here can be referenced in the definition using the ${body} variable
[/@myMacro]
</programlisting>
<emphasis>Reference with ordinal parameters</emphasis>
<programlisting>
[@myMacro someContextVar "foo" "bar" null null someVar]
	The content here can be referenced in the definition using the ${body} variable
[/@myMacro]
</programlisting>
				</para>
				<section id="macros_parameters_template">
					<title>Object Oriented Macros</title>
					<para>
						The real power of the macros is the ability to provide template-defined parameters that are defined within the body of the
						macro reference which can be evaluated programatically inside the macro definition.  Template-defined parameters use the same
						format as a standard macro reference.  So, how do you determine if an element is a macro reference or a template-defined parameter?
						<itemizedlist>
							<listitem>Template-defined parameters must be defined as parameters with the suffix of [...] for the macro definition.</listitem>
							<listitem>Template-defined parameters must not have a namespace (no '.' in the macro name)</listitem>
						</itemizedlist>
						See the following macro reference:
<programlisting>
[@tab.pane id="myTab"]
	[@page title="Page 1" visible=true]
		Page 1 contents
	[/@page]
	[@page title="Page 2"]
		Page 2 contents
	[/@page]
[/@tab.pane]
</programlisting>
						Notice that even though the pane macro is in the tab namespace, the page template-defined parameters do not reference the namespace.
						Now, see the macro definition (which would be in the tab macro library) 
<programlisting>
[#macro pane id *page[*title id=title?humpbackCase visible=false]]
	&lt;div id="${id}" class="tab"&gt;
		[#foreach page in page]
			&lt;div id="${page.id}" class="page" [#if visible==false]style="display: none"[/#if]"&gt;
				&lt;label&gt;${page.title}&lt;/label&gt;
				$!{page.body}
			&lt;/div&gt;
		[/#foreach]
	&lt;/div&gt;
[/#macro]
</programlisting>
This is what the output would be (I've changed the spacing for readability)
<programlisting>
&lt;div id="myTab" class="tab"&gt;
	&lt;div id="page1" class="page"&gt;
		Page 1 contents
	&lt;/div&gt;
	&lt;div id="page2" class="page" style="display: none"&gt;
		Page 2 contents
	&lt;/div&gt;
&lt;/div&gt;
</programlisting>
					</para>
				</section>
				<section>
					<title>Common Template-defined Parameters</title>
					<para>
						With the introduction of template-defined parameters, it is beneficial to be able to externalize common template-defined parameters.  This can be
						done by reference template-defined parameters in a macro with the <code>[.@...</code> syntax.
					</para>
					<para>
						In this reference the commonPages macro is not a template-defined parameter but a standard macro reference with will include template defined parameters. 
This is what the output would be (I've changed the spacing for readability)
<programlisting>
[@tab.pane id="myTab"]
	[@tab.commonPages/]
[/@tab.pane]
</programlisting>
						Notice that the pane macro has not changed since the previous example.  We have just added the commonPages macro to this library.
<programlisting>
[#macro pane id *page[*title id=title?humpbackCase visible=false]]
	&lt;div id="${id}" class="tab"&gt;
		[#foreach page in page]
			&lt;div id="${page.id}" class="page" [#if visible==false]style="display: none"[/#if]"&gt;
				&lt;label&gt;${page.title}&lt;/label&gt;
				$!{page.body}
			&lt;/div&gt;
		[/#foreach]
	&lt;/div&gt;
[/#macro]

[#macro commonPages]
	[.@page title="Page 1" visible=true]
		Page 1 contents
	[/.@page]
	[.@page title="Page 2"]
		Page 2 contents
	[/.@page]
[/#macro]
</programlisting>
And, the output is the same as before
<programlisting>
&lt;div id="myTab" class="tab"&gt;
	&lt;div id="page1" class="page"&gt;
		Page 1 contents
	&lt;/div&gt;
	&lt;div id="page2" class="page" style="display: none"&gt;
		Page 2 contents
	&lt;/div&gt;
&lt;/div&gt;
</programlisting>
					</para>
				</section>
			</section>
			<section id="macros_libraries">
				<title>Macro Libraries</title>
				<para>
					Macro libraries can group similar macros in the same namespace.  A macro library is a file (usually ending with .zsm) which only contains
					macro definitions.  These macro libraries can be imported using the API using the following syntax:
<programlisting>
ZipEngine engine = new ZipEngine();
engine.addMacroLibrary(namespace, resourceName);
</programlisting>
or
<programlisting>
ZipEngine engine = new ZipEngine();
engine.addMacroLibrary(new File("path to resource or directory"));
</programlisting>
				</para>
				Referencing macros defined in a macro library requires the namespace to be added to the reference name.  For example, if the "foo" macro 
				was defined in a macro library imported to the "abc" namespace, a reference to that macro would use the following syntax:
<programlisting>
[@abc.foo ...] [/@abc.foo]
</programlisting>
				Any macros that are defined within a macro library do not need to refer to any other macros defined in the same library with a namespace.
			</section>
		</chapter>
	</book>
	<book id="developersGuide">
		<bookinfo>
			<title>ZipScript Developers Guide</title>
		</bookinfo>
		<chapter id="developersGuide_templatesEvaluators">
			<title>Templates and Evaluators</title>
			<section id="te_overview">
				<title>Overview</title>
				<para>
					With ZipScript, you can do more than just merge a data model with a
					static template.  You can also evaluate expressions to retrieve boolean
					or object values.
				</para>
				<para>
					This can be useful in situations like storing conditional logic in static
					properties files or representing runtime data with static templates.  Most
					applications use properties files or xml which, with ZipScript, can be used
					in a much more powerful and meaningful way.
				</para>
			</section>
			<section id="te_merging">
				<title>Merging</title>
				<indexterm><primary>templates</primary><secondary>merging</secondary></indexterm>
				<para>
					Like other script engines, ZipScript can merge a static template with a data
					model.  The syntax for this is as follows:
<programlisting>
import hudson.zipscript.ZipEngine;
import hudson.zipscript.template.Template;
...
// initialize
ZipEngine.getInstance().init(initProperties);
// parse the resource and retrieve the template
Template t = ZipEngine.getInstance().getTemplate("someTemplateName.zs");
// create the context and execute
Map context = new HashMap();
context.put("foo", "bar");
// merge the object model with the template
String mergedResult = t.merge(context);
</programlisting>
				</para>
			</section>
			<section id="te_booleans">
				<title>Evaluating Booleans</title>
				<indexterm><primary>booleans</primary><secondary>evaluation</secondary></indexterm>
				<para>
					Boolean values can be evaluated from ZipScript expressions.  The syntax is as
					follows:
<programlisting>
import hudson.zipscript.ZipEngine;
import hudson.zipscript.template.Evaluator;
...
// initialize
ZipEngine.getInstance().init(initProperties);
// parse the resource and retrieve the template
Evaluator e = ZipEngine.getInstance().getEvaluator(conditionalStatement);
// create the context and execute
Map context = new HashMap();
context.put("foo", "bar");
// merge the object model with the evaluator to get the boolean value
boolean rtn = e.booleanValue(context);
</programlisting>
				</para>
			</section>
			<section id="te_objects">
				<title>Evaluating Objects</title>
				<indexterm><primary>objects</primary><secondary>evaluation</secondary></indexterm>
				<para>
					Java Objects can be evaluated from ZipScript expressions.  The syntax is as
					follows:
<programlisting>
import hudson.zipscript.ZipEngine;
import hudson.zipscript.template.Evaluator;
...
// initialize
ZipEngine.getInstance().init(initProperties);
// parse the resource and retrieve the template
Evaluator e = ZipEngine.getInstance().getEvaluator(conditionalStatement);
// create the context and execute
Map context = new HashMap();
context.put("foo", "bar");
// merge the object model with the evaluator to get the object value
Object rtn = e.objectValue(context);
</programlisting>
				</para>
			</section>
		</chapter>
		<chapter id="developersGuide_resourceLoading">
			<title>Resource Loading</title>
			<indexterm><primary>resource</primary><secondary>loading</secondary></indexterm>
			<section id="resourceLoading_overview">
				<title>Overview</title>
				<para>
					The ZipScript engine will actually work in default mode if not initialized.
					This mode consists of the following resource loaders:
					<variablelist>
						<varlistentry><term>Template merging</term><listitem>Classpath resource files are retrieved</listitem></varlistentry>
						<varlistentry><term>Boolean evaluation</term><listitem>The parameter passed with ZipEngine.getEvaluator(String) is used as the actual ZipScript expression</listitem></varlistentry>
						<varlistentry><term>Object evaluation</term><listitem>The parameter passed with ZipEngine.getEvaluator(String) is used as the actual ZipScript expression</listitem></varlistentry>
					</variablelist>
				</para>
			</section>
			<section id="developersGuide_resourceLoaders">
				<title>Resource Loaders</title>
				<para>
					Resource loaders are used to retrieve the contents of a resource to create a Template or an Evaluator.  All resource loader properties must be prefixed with
					the resource loader context.  For example, to specify a property <code>foo</code> for the template resource loader use:
<programlisting>
templateResourceLoader.foo=bar
</programlisting>
				</para>
				<section>
					<title>StringResourceLoader</title>
					<para>
						<code>hudson.zipscript.resource.StringResourceLoader</code>: Use the getTemplate/getEvaluator parameter directly as the resource
					</para>
				</section>
				<section>
					<title>ClasspathResourceLoader</title>
					<para>
						<code>hudson.zipscript.resource.ClasspathResourceLoader</code>: Loads a resource from the classpath.
					</para>
					<para>
						Init properties:
						<variablelist>
							<varlistentry><term>pathPrefix</term><listitem>Prefix to append to all resourceses</listitem></varlistentry>
						</variablelist>
					</para>
				</section>
				<section>
					<title>FileResourceLoader</title>
					<para>
						<code>hudson.zipscript.resource.FileResourceLoader</code>: Loads a resource from the filesystem.
					</para>
					<para>
						Init properties:
						<variablelist>
							<varlistentry><term>pathPrefix</term><listitem>Prefix to append to all resourceses</listitem></varlistentry>
						</variablelist>
					</para>
				</section>
				<section>
					<title>URLResourceLoader</title>
					<para>
						<code>hudson.zipscript.resource.URLResourceLoader</code>: Loads a resource from a URL.
					</para>
					<para>
						Init properties:
						<variablelist>
							<varlistentry><term>pathPrefix</term><listitem>Prefix to append to all resourceses</listitem></varlistentry>
						</variablelist>
					</para>
				</section>
			</section>
			<section id="resourceLoading_templates">
				<title>Templates</title>
				<indexterm><primary>resource</primary><secondary>templates</secondary></indexterm>
				<para>
					The following property can be used to set the template resource loader:
					<varlistentry><term>templateResourceLoader.class</term><listitem>classname implementing hudson.zipscript.resource.ResourceLoader</listitem></varlistentry>
				</para>
			</section>
			<section id="resourceLoading_evaluators">
				<title>Evaluators</title>
				<indexterm><primary>resource</primary><secondary>evaluator</secondary></indexterm>
				<para>
					The following property can be used to set the evaluator resource loader:
					<varlistentry><term>evalResourceLoader.class</term><listitem>classname implementing hudson.zipscript.resource.ResourceLoader</listitem></varlistentry>
				</para>
			</section>
			<section id="resourceLoading_macros">
				<title>Macros</title>
				<indexterm><primary>resource</primary><secondary>macros</secondary></indexterm>
				<para>
					By default, the macro resource loader will be the same as the template resource loader.  The following property can be used to set the macro resource loader:
					<varlistentry><term>macroLibResourceLoader.class</term><listitem>classname implementing hudson.zipscript.resource.ResourceLoader</listitem></varlistentry>
				</para>
			</section>
		</chapter>
		<chapter id="context">
			<title>Context</title>
			<section id="context_overview">
				<title>Overview</title>
				A context is used to contain data referenced with the ZipScript template.  The context can literally be anything as the parameter type is java.lang.Object.
			</section>
			<section id="context_map">
				<title>Map Context</title>
				Using a <code>java.util.map</code> as the context will allow variable references to retrieved data from the map with the matching key.  Since the '.' character
				is normally used to represent a separation of object and property a separate naming procedure must be used for Map keys that contain this character.  Assuming
				a map entry with the key of 'foo.bar' exists, this can be retrieved using the variable format ${'foo.bar'}.
			</section>
			<section id="context_xml">
				<title>XML DOM Context</title>
				This is not implemented yet but will be soon.
			</section>
			<section id="context_object">
				<title>Object</title>
				The object getter methods can be referenced directly with variables.  For example if an object with a getFoo() method was used as the context, the variable
				${foo} can be used to access this property.  The set directive will try to find a set method to match.  If none is found, a separate datastore is used to
				contain the value.
			</section>
			<section id="context_custom">
				<title>Implemting Your Own</title>
				To provide your own context functionality, you need to use an object which implements <code>hudson.zipscript.parser.context</code>.  It is a good idea to extend
				from hudson.zipscript.parser.context.AbstractContext as this will contain functionality you need not reproduce.
			</section>
		</chapter>
		<chapter id="properties">
			<title>Properties</title>
			<para>
				Listed below are all the properties that affect ZipScript operation
				<variablelist>
					<varlistentry><term>templateResourceLoader.class</term><listitem>default: hudson.zipscript.resource.ClasspathResourceLoader</listitem></varlistentry>
					<varlistentry><term>evalResourceLoader.class</term><listitem>default: hudson.zipscript.resource.StringResourceLoader</listitem></varlistentry>
					<varlistentry><term>macroLibResourceLoader.class</term><listitem>default: hudson.zipscript.resource.StringResourceLoader</listitem></varlistentry>
					<varlistentry><term>variable.nonSilencedNullError</term><listitem>default: true</listitem></varlistentry>
					<varlistentry><term>encoding.url</term><listitem>default: UTF-8</listitem></varlistentry>
					<varlistentry><term>resource.checkModification</term><listitem>default: true</listitem></varlistentry>
				</variablelist>
			</para>
		</chapter>
	</book>
</set>